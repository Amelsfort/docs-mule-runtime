= Scatter-Gather Router
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Scatter-Gather component is a routing event processor that processes a Mule event through different parallel processing routes that contain one or more event processors. Each route receives a reference to the Mule event and executes a sequence of one or more event processors. Each of these routes uses a separate thread and creates a new Mule event with its own payload, attributes, and variables. The Scatter-Gather component then combines the Mule events returned by each processing route into a new Mule event that is passed to the next event processor only after every route completes successfully.

The Scatter-Gather component executes each route in parallel, not sequentially. Parallel execution of routes can greatly increase the efficiency of your Mule application and may provide more information than sequential processing.

The following diagram details the behavior of the Scatter-Gather component:

image::mruntime-scatter-gather.png[Diagram of Scatter-Gather Component]

<1> The Scatter-Gather component receives a Mule event and sends a reference of this Mule event to each processing route.
<2> Each of the processing routes start executing in parallel. Once all processors inside a route finish processing, the route generates a new Mule event as a result.
<3> After all processing routes have finished execution, the Scatter-Gather component creates a new Mule event that combines all resulting Mule events from each route, and then passes the new Mule event to the next component in the flow.

WARNING: A Scatter-Gather component cannot be configured with only one route. A Mule application with this configuration throws an exception and does not start, at least two routes are necessary in a Scatter-Gather configuration to be valid.

== Error Handling Inside Scatter-Gather Routes

You can use a Try scope in each route of a Scatter-Gather component to handle any errors that might be generated by a route’s event processors. Unhandled errors that are thrown because of a problem in a route cause the Scatter-Gather component to also throw an error of type `MULE:COMPOSITE_ERROR`. The component throws this error only after every route completes, either with a successful execution or with an error that causes the route to fail. Event processing does not proceed further than the Scatter-Gather component in the flow. Instead, the flow branches to your error-handling event processors. The `MULE:COMPOSITE_ERROR` error object gathers together not only the errors from the route that failed, but also the Mule events from completed routes, so that your application can still process Mule events from the routes that completed by using your error-handling event processors.

To illustrate how this works, consider the following two cases:

* The routes in a Scatter-Gather component each contain a Try scope. One of the routes generates an error that is successfully handled by that route’s Try scope, so the route is still able to generate a Mule event. The Scatter-Gather component consolidates the Mule events from all routes into a new Mule event, as usual, and passes the consolidated event to the next event processor.

* An error occurs in a route. This route either does not contain a Try scope or the error is of a type that the Try scope cannot handle. Although all the other routes complete processing, the failed route causes the Scatter-Gather component to throw a `MULE.COMPOSITE ERROR` error, which the flow passes to the Error Handler component that you have configured for your flow. The error-handling event processors are able to process the Mule events from the completed routes.

Example of handling these errors:
[source,xml,linenums]
----
<flow name="errorHandler">
    <scatter-gather>
        <route>
            <raise-error type="APP:MYERROR"/>
        </route>
        <route>
            <set-payload value="apple"/>
        </route>
    </scatter-gather>
    <error-handler>
        <on-error-continue type="COMPOSITE_ROUTING">
            <!-- This will have the error thrown by the first route -->
            <logger level="WARN" message="#[error.errorMessage.payload.failures['0']]"/>
            <!-- This will be a null value -->
            <logger level="WARN" message="#[error.errorMessage.payload.failures['1']]"/>

            <!-- This will be a null value -->
            <logger level="WARN" message="#[error.errorMessage.payload.results['0']]"/>
            <!-- This will have the result of the second (correctly executed) route -->
            <logger level="WARN" message="#[error.errorMessage.payload.results['1']]"/>
        </on-error-continue>
    </error-handler>
</flow>
----

== Variable Propagation

Every route starts with the same initial variable values. Modifications to a variable within a specific route do not affect other routes. So, if a variable is added or modified in one route, then, after aggregation, the value is defined by that route. If a variable is added or modified by more than one route, the value is added to a list of all the values defined for that variable within all the routes, for example:

[source,xml,linenums]
----
<set-variable variableName="var1" value="var1"/>
<set-variable variableName="var2" value="var2"/>
<scatter-gather doc:name="Scatter-Gather" doc:id="abc665e0-6119-4ecb-9f8b-52dbcbb1d488" >
	<route >
		<set-variable variableName="var2" value="newValue"/>
        <set-variable variableName="var3" value="appleVal"/>
	</route>
	<route >
		<set-variable variableName="var3" value="bananaVal"/>
	</route>
	<route >
		<set-variable variableName="var3" value="otherVal"/>
        <set-variable variableName="var4" value="val4"/>
	</route>
</scatter-gather>
----

After aggregation, the variables are:

`{var1: "var1", var2: "newValue", var3: ["appleVal, bananaVal, otherVal"], var4: "val4"}`

== Handle Timeout Errors in a Scatter-Gather

You can configure a timeout for a Scatter-Gather component. If a route does not complete processing before the period of time set in the timeout expires, the route throws a `MULE:TIMEOUT` error. This error is then handled the same way as any other error generated from a route: after each route completes (either by completing its last event processor or by throwing a `MULE:TIMEOUT` error), the successful results and errors are collected together and thrown by the Scatter-Gather component as a `MULE:COMPOSITE` error, which can then be processed in an error handler.

== Example
In Anypoint Studio, you can download and open the example project _Scatter-Gather Flow Control_ from Anypoint Exchange to learn more about how to use the Scatter-Gather component. This example shows the usage of the scatter-gather control flow to aggregate data in parallel and return the result in JSON.

The example uses prepared data as input for two resources that should be aggregated. The data represents information about two contacts and has the following structure:

|===
Resource|`firstname`|`surname`|`phone`|`email`
|contacts-1.csv
|John
|Doe
|096548763
|john.doe@texasComp.com

|contacts-2.csv
|Jane
|Doe
|091558780
|jane.doe@texasComp.com
|===

DataWeave is used to aggregate the data. The information about the contacts is aggregated to a JSON structure that represents data from both resources.

To download and open this example project while you are in Anypoint Studio, click the Exchange icon in the upper-left corner. Then, in the window that opens, log into Anypoint Exchange and search on the name of the project.

== Throws

* `MULE:ROUTING`
* `MULE:COMPOSITE_ROUTING`

== See Also

* xref:scatter-gather-xml-reference.adoc[Scatter-Gather XML Reference]
* xref:about-components.adoc[Core Components]
* xref:transaction-management.adoc#tx_scopes_routers[How Transactions Affect Scopes and Routers]
