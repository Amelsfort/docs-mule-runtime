= XML Format

MIME Type: `application/xml`

ID: `xml`

The XML data structure is mapped to DataWeave objects that can contain other
`Object`, `String` or `Null` values. XML uses unbounded elements to represent collections, which are mapped to repeated keys in DataWeave objects. In addition, DataWeave natively supports `namespaces`, `CData` an `xsi:types`.

To understand the parsing strategies that DataWeave readers and writers can apply to this format, see xref:#dw_readers_writers[DataWeave Parsing Strategies].

[[format_xml_cdata]]
== CData Custom Type

`CData` is a custom DataWeave data type for XML that is used to identify a Character DATA (CDATA) block. The `CData` type tells the XML writer to wrap content inside a `CDATA` block or to check for an input string inside a `CDATA` block. In DataWeave, `CData` inherits from the type `String`.

== Streaming

Starting in Mule version 4.3.0, XML supports <<streaming, streaming>>. You need to specify the following reader property to activate streaming:

* `collectionPath`:
+
Specifies a path expression the identifies the location of the elements to stream.

When streaming, the XML parser can start processing content without having all the XML content.

[[examples]]
== Examples

The following examples show uses of the XML format.

* <<example1>>
* <<example2>>
* <<example3>>
* <<example4>>
* <<example5>>
* <<example6>>
* <<example7>>
* <<example8>>
* <<example9>>
* <<example10>>
* <<example11>>
* <<example12>>
* <<example13>>
* <<example14>>

[[example1]]
==== Example

This example shows how to set up XML streaming, which requires you to specify the following reader properties:

* `streaming=true`
* `collectionPath="root.repeated"`

The `collectionPath` setting selects to the elements to stream. that are going to be stream that are al the `user`

==== Input

The following XML serves as the input payload to the DataWeave script. Assume that it is the content of an XML file `myXML.xml`.

.myXML.xml
[source,xml,linenums]
----
<root>
    <text>
        Text
    </text>
    <repeated>
        <user>
            <name>Mariano</name>
            <lastName>de Achaval</lastName>
            <age>36</age>
        </user>
        <user>
            <lastName>Shokida</lastName>
            <name>Leandro</name>
            <age>30</age>
        </user>
        <user>
            <age>29</age>
            <name>Ana</name>
            <lastName>Felissati</lastName>

        </user>
        <user>
            <age>29</age>
            <lastName>Chibana</lastName>
            <name>Christian</name>
        </user>

    </repeated>
</root>
----

==== Source

The reader property settings in the DataWeave script tell the XML reader to stream the input and process the repeated keys. The script uses the DataWeave `map` function to iterate over the repeated keys.

[source,dataweave,linenums]
----
%dw 2.0
var myInput  readUrl('classpath://myXML.xml', 'application/xml', {streaming:true, collectionPath: "root.repeated"})
output application/dw
---
myInput.root.repeated.*user map {
    n: $.name,
    l: $.lastName,
    a: $.age
}
----

==== Output

The script also transforms the mapped input XML to the DataWeave (dw) format and MIME type.

[source,json,linenums]
----
[
  {
    "n": "Mariano",
    "l": "de Achaval",
    "a": "36"
  },
  {
    "n": "Leandro",
    "l": "Shokida",
    "a": "30"
  },
  {
    "n": "Ana",
    "l": "Felissati",
    "a": "29"
  },
  {
    "n": "Christian",
    "l": "Chibana",
    "a": "29"
  }
]
----

[[example2]]
==== Example: Null or Empty String in XML

Because there is no standard way to represent a `null` value in XML, the reader maps to `null` when the `nil` attribute is set to `true`.

This example maps `nil` to `null`.

==== Input

The following XML serves as the input payload to the DataWeave script.

[source,xml,linenums]
----
<book  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <author xsi:nil="true"/>
</book>
----

==== Source

The DataWeave script transforms the input XML to the JSON format and MIME type.

[source,dataweave,linenums]
----
output application/json
---
payload
----

==== Output

The output is in the JSON format.

[source,json,linenums]
----
{
  "book": {
    "author": null
  }
}
----

[[example3]]
==== Example: Setting the `nullValueOn` Property

Setting the reader property `nullValueOn` to `blank` or `empty`. By default is set to `blank`.

This example shows how the property `title` and `author` are mapped to null as `nullValueOn` is set to `blank`.

==== Input

TODO

[source,xml,linenums]
----
<book>
    <author></author>
    <title>

</title>
</book>
----

==== Source

TODO

[source,dataweave,linenums]
----
output application/json
---
payload
----

==== Output

TODO

[source,json,linenums]
----
{
  "book": {
    "author": null,
    "title": null
  }
}
----

[[example4]]
==== Example

TODO

This example shows how the property `title` is mapped to a `String` and `author` is mapped to null as `nullValueOn` is set to `empty`.

==== Input

TODO

[source,xml,linenums]
----
<book>
    <author></author>
    <title>

</title>
</book>
----

==== Source

TODO

[source,dataweave,linenums]
----
output application/json
---
payload
----

==== Output

TODO

[source,json,linenums]
----
{
  "book": {
    "author": null,
    "title": "\n\n"
  }
}
----

[[example5]]
==== Example

TODO - When the reader property `nullValueOn` is set to `blank` or is set `empty`. By default is set to `blank`

TODO

This example shows how the property `title` and `author` are mapped to  String` as `nullValueOn` is set to `none`.

=== Input

TODO

[source,xml,linenums]
----
<book>
    <author></author>
    <title>

</title>
</book>
----

==== Source

TODO

[source,dataweave,linenums]
----
output application/json
---
payload
----

==== Output

TODO

[source,json,linenums]
----
{
  "book": {
    "author": "",
    "title": "\n\n"
  }
}
----

[[example6]]
==== Example: TODO

TODO
This example shows how a simple XML is being mapped to DataWeave canonical representation.

==== Input

TODO

[source,xml,linenums]
----
<users>
  <company>MuleSoft</company>
  <user name="Leandro" lastName="Shokida"/>
  <user name="Mariano" lastName="Achaval"/>
</users>
----

==== Source

The DataWeave script transforms the XML input payload to the DataWeave (dw) format and MIME type.

[source,dataweave,linenums]
----
output application/dw
---
payload
----

==== Output

TODO

[source,dataweave,linenums]
----
{
  users: {
    company: "MuleSoft",
    user @(name: "Leandro",lastName: "Shokida"): "",
    user @(name: "Mariano",lastName: "Achaval"): ""
  }
}
----

[[example7]]
== Example

This example how namespaces are being mapped to DataWeave canonical representation.

=== Input

TODO

[source,xml,linenums]
----
<root>
    <h:table xmlns:h="http://www.w3.org/TR/html4/">
      <h:tr>
        <h:td>Apples</h:td>
        <h:td>Bananas</h:td>
      </h:tr>
    </h:table>

    <f:table xmlns:f="https://www.w3schools.com/furniture">
      <f:name>African Coffee Table</f:name>
      <f:width>80</f:width>
      <f:length>120</f:length>
    </f:table>
</root>
----

==== Source

The DataWeave script transforms the XML input payload to the DataWeave (dw) format and MIME type.

[source,dataweave,linenums]
----
output application/dw
---
payload
----

==== Output

TODO

[source,dataweave,linenums]
----
ns h http://www.w3.org/TR/html4/
ns f https://www.w3schools.com/furniture
---
{
  root: {
      h#table: {
        h#tr: {
          h#td: "Apples",
          h#td: "Bananas"
        }
      },
      f#table: {
        f#name: "African Coffee Table",
        f#width: "80",
        f#length: "120"
      }
  }
}
----

[[example8]]
==== Example

TODO

This example shows how `CData` type is being used to create CDATA xml element.

==== Source

TODO

[source,dataweave,linenums]
----
%dw 2.0
output application/xml
---
{
    test: "A text <a>" as CData
}
----

==== Output

TODO

[source,xml,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<test><![CDATA[A text <a>]]></test>
----

[[example9]]
==== Example

TODO
This example shows how `CData` to check if a String value is a CDATA

==== Input

TODO

[source,xml,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<test><![CDATA[A text <a>]]></test>
----

==== Source

TODO

[source,dataweave,linenums]
----
%dw 2.0
output application/json
---
{
    test: payload.test is CDATA
}
----

==== Output

TODO

[source,json,linenums]
----
{
    "test": true
}
----

[[example10]]
==== Example

TODO

This example shows how `inlineCloseOn` with value none use different tag to close the xml.

==== Source

TODO

[source,dataweave,linenums]
----
output application/xml inlineCloseOn="none"
---
{
  someXml: {
    parentElement: {
      emptyElement1: null,
      emptyElement2: null,
      emptyElement3: null
    }
  }
}
----

==== Output

TODO

[source,xml,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<someXml>
  <parentElement>
    <emptyElement1></emptyElement1>
    <emptyElement2></emptyElement2>
    <emptyElement3></emptyElement3>
  </parentElement>
</someXml>
----

[[example11]]
==== Example

TODO
Xml encodes collections using repeated elements (UNBOUNDED elements) this is represented in DataWeave by repeating the same key.
This example shows how to convert a JSON Array into a repeated xml element.

==== Input

TODO

[source,json,linenums]
----
{
  "friends": [
    {"name": "Mariano"},
    {"name": "Shoki"},
    {"name": "Tomo"},
    {"name": "Ana"}
  ]
}
----

==== Source

TODO

[source,dataweave,linenums]
----
%dw 2.0
output application/xml
---
friends: {
    (payload.friends)
}
----

==== Output

TODO

[source,xml,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<friends>
  <name>Mariano</name>
  <name>Shoki</name>
  <name>Tomo</name>
  <name>Ana</name>
</friends>
----

//NOT NEW
[[example12]]
==== Example
TODO

==== Input
TODO

[source,xml,linenums]
----
<users>
  <company>MuleSoft</company>
  <user name="Leandro" lastName="Shokida"/>
  <user name="Mariano" lastName="Achaval"/>
</users>
----

==== Output
TODO
.DataWeave Script:
[source,dataweave,linenums]
----
{
  users: {
    company: "MuleSoft",
    user @(name: "Leandro",lastName: "Shokida"): "",
    user @(name: "Mariano",lastName: "Achaval"): ""
  }
}
----

//NOT NEW
[[example13]]
==== Example

TODO
This example shows how the property `title` is mapped to a `String` and `author` is mapped to null as `nullValueOn` is set to `empty`.

==== Input

TODO
[source,xml,linenums]
----
<book>
    <author></author>
    <title>

</title>
</book>
----

==== Source

TODO
[source,dataweave,linenums]
----
output application/json
---
payload
----

==== Output

[source,json,linenums]
----
{
  "book": {
    "author": null,
    "title": "\n\n"
  }
}
----

//NOT NEW
[[example14]]
==== Example: Use of the inlineCloseOn Parameter

The `inlineCloseOn` writer property indicates whether to output empty elements with the default structure (`none`) or to close the element by setting the value to `empty`.

.Empty Elements That are Unlosed:
[source,xml,linenums]
----
<someXml>
  <parentElement>
    <emptyElement1></emptyElement1>
    <emptyElement2></emptyElement2>
    <emptyElement3></emptyElement3>
  </parentElement>
</someXml>
----

.Empty Elements That are Closed:
[source,xml,linenums]
----
<payload>
  <someXml>
    <parentElement>
      <emptyElement1/>
      <emptyElement2/>
      <emptyElement3/>
    </parentElement>
  </someXml>
</payload>
----

See also, xref:dataweave-cookbook-output-self-closing-xml-tags.adoc[Example: Outputting Self-closing XML Tags].


[[properties]]
== Configuration Properties

DataWeave supports the following configuration properties for the XML format.

=== Reader Properties

The XML reader accepts optional parameters that provide instructions for reading input data.

//TODO: COPYEDIT, LOTS OF TODOS

[cols="1,1,1,3a", options="header"]
|===
| Parameter | Type | Default | Description
|`collectionPath`  |`String`| TODO | TODO: This path should point to the location in the document where the collection is located.
| `externalEntities` | `Boolean` | `false` | Indicates whether external entities
should be processed or not. By default this is disabled to avoid XXE attacks.
Valid values are `true` or `false`.
| `indexedReader` | `Boolean` | `true` | If the indexed XML reader should be
used when the threshold is reached. Valid values are `true` or `false`.
| `maxAttributeSize` | `Number` | `-1` | Sets the maximum number of characters
accepted in an XML attribute. Available since Mule 4.2.1.
| `maxEntityCount` | `Number` | `1` | The maximum number of entity expansions.
The limit is in place to avoid Billion Laughs attacks.
| `nullValueOn` | `String` | `blank` | TODO: If a tag with empty or blank text should
be read as null. Valid values are `empty`, `none`, or `blank`.
|`optimizeFor` |`String`| `'speed'` | TODO: Indicates how to configure the Xml Parser.
|`streaming` |`Boolean` | `false` | TODO: Indicates whether to stream input (use only if entries are accessed sequentially). Valid Options are `true` or `false`.
|`supportDtd` |`Boolean` | `true` | TODO: Indicates whether to enable DTD handling; disabling means that both internal and external subsets are skipped and not processed. Valid Options are `true` or `false`.
|===

== Writer Properties

The XML writer accepts optional parameters that provide instructions for writing output data.

[cols="1,1,1,3a", options="header"]
|===
| Parameter | Type | Default | Description
| `bufferSize` | `Number` | `8192` | Size of the buffer writer.
| `encoding` | `String` | None |Encoding for the writer to use.
| `deferred` | `Boolean` | `false` |Property for deferred output.
  Valid values are `true` or `false`.
| `escapeCR` | `Boolean` | `false` | Whether to escape a carriage return (CR).
Valid values are `true` or `false`. Available since Mule 4.2.1.
| `indent` | `Boolean` | `true` |Indicates whether to indent the output.
Valid values are `true` or `false`.
| `inlineCloseOn` | `String` | `empty` |When the writer should use inline close
tag. Valid values are `empty` or `none`.
| `onInvalidChar` | `String` | None |Valid values are `base64`, `ignore`, or `none`.
| `writeNilOnNull` | `Boolean` | `false` |Whether to write a nil attribute when
the value is null. Valid values are `true` or `false`.
| `skipNullOn` | `String` | None |Skips `null` values in the specified data
structure. By default it does not skip. Valid values are `elements`, `attributes`,
or `everywhere`.

* `arrays` +
Ignore and omit `null` values from JSON output, for example, `output application/json skipNullOn="arrays"`.
* `objects`+
Ignore an object that has a null value. The output contains an empty object (`{}`) instead of the object with the null value, for example, `output application/json skipNullOn="objects"`.
* `everywhere` +
Apply `skipNullOn` to arrays and objects, for example, `output application/json skipNullOn="everywhere"`.

| `writeDeclaration` | `Boolean` | `true` |Indicates whether to write the XML
header declaration. Valid values are `true` or `false`.
|===

[[mime_type]]
== Supported MIME Types

The XML format supports the following MIME types.

[cols="1", options="header"]
|===
| MIME Type
|`*/xml`
|`*/*+xml`
|===
