= Type System
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

DataWeave 2.0 supports a type system. To take advantage of the type checking that the type system executes, you need to provide constraint expressions for variables and functions described in this section. For information on how values for these types are defined, refer to xref:dataweave-types.adoc[Value Constructs for Types].



A type system defines a set of constraints to a set of constructs, such as:

* Variables
* Function parameters

These constraints are used in the type checking phase, when DataWeave ensures that the values assigned
to variables or the arguments for a function call respect its constraints. For example:

.DataWeave Script
----
%dw 2.0
import * from dw::core::Strings
output application/json

var userName: String = "John"
----

The variable definition for `userName` has the constraint of assigning a value of type `String`.
If some other type value is assigned, a type checking error is raised.

.DataWeave Script
----
%dw 2.0
import * from dw::core::Strings
output application/json

fun toUser(id: Number, userName: String): String = "you called the function toUser!"
----

The constraints to call the function `toUser` are that the first argument has to be of type `Number`, the second one of type `String` (to be coercible to those types). Another constraint is that the result of the function has to be of type `String` (this constraint isn't used in the call for `toUser`; it's applied to its definition to validate that the function body generates the proper type).

----
toUser(123, "John")
toUser("123", true)
----

Though you might expect the second call to fail, autocoercion enables the call to be successful, and both calls work. In the case of the second function call, there is an autocoercion of the `String` value `"123"` to the `Number` value `123`, and the `Boolean` value `true` to the `String` value `"true"`, which makes it possible to call the function. +
An example of a call that throws a type checking error is `toUser("a 12", "John")` because the String `"a 12"` isn't coercible to a `Number` type. +

DataWeave also uses a global type inference algorithm to validate your code even if no types are specified as
constraints.

[NOTE]
 The use of constraints is optional, but constraints can be useful in big scripts or multiple scripts. The type system can help you avoid bugs in your DataWeave logic because it causes the type-checking algorithm to run.

The types supported by the DataWeave type system are divided into three categories:

* Simple Types
* Composite Types
* Complex Types

== Simple Types

Simple types represent values such as strings, Booleans, and so on. These values are atomic; they are not composed of other values. These are the simple types:

* String
* Boolean
* Number
* Regex
* Null
* Temporal: Date, DateTime, LocalDateTime, LocalTime, Time, Period
//Key, KeyValuePairType, NameType, NameValuePairType, NamespaceType, RangeType , ReferenceType, TypeParameter, TypeType, UriType

=== Null

Null is a type of only one value, the value `null`, which means that this value `null` cannot be assigned to the type String or any other type except for the type Null.

For example, the repeat function in the String Module has the signature `repeat(String, Number): String`, which means that it only accepts as a first parameter a value of type String, and as a second parameter a value of type Number. The function returns a value of type String.

.DataWeave Script
----
%dw 2.0
import * from dw::core::Strings
output application/json
---
repeat("a", 3)
----

This returns `&quot;aaa&quot;`, but:

.DataWeave Script
----
%dw 2.0
import * from dw::core::Strings
output application/json
---
repeat(null, 3)
----

Throws an error because the value `null` cannot be assigned to the parameter that expects a value of type String.

.DataWeave Script
----
%dw 2.0
import * from dw::core::Strings
output application/json
---
repeat(Null, 3)
----

In this case we are assigning to the first parameter a value that is the type Null (the type of this value
is `Type&lt;Null&gt;`), and returns `&quot;NullNullNull&quot;` because there is an autocoercion that coerces the value to be of type String (`&quot;Null&quot;`).

Some other functions may have an overloaded signature for the function (the function has multiples definitions for different parameters types) that let it be called with `null`.

For example, the `isNumeric` function from dw::core::Strings has the signature `isNumeric(String): Boolean` (receives a string and returns if that string is numeric) but it is also defined as `isNumeric(Null): Boolean`. +

So if you call the function `isNumeric` with a null (`isNumeric(null)`) this does not throw an exception. At runtime, the function dispatching algorithm selects the correct function based on the actual types of the values used. The function returns false because of the definition of `isNumeric` for null as the argument.

== Composite Types

Composite types contains other values inside it. These composite types are Array, Object and Function.

=== Array Type

An Array is of type `Array&lt;T&gt;` where `T` is a type parameter that defines the type of the elements inside the Array. For example, the syntax to define a variable with the type Array of `Number` is:

----
var idsList: Array<Number> = [1, 22, 333, 4444]
----

The variable `idsList` only passes the type checking phase when the array assigned to it only contains Numbers.

=== Object Type

In order to define an object type there are two ways, either `Object` or `{}`, they both define an open object and don't specify any constraint to their key value pairs. Open and close objects are later defined in this section.

The syntax to define an object type with a set of constraints for its key value pairs, is very similar to defining an object value:

----
{
    keyName @(attrName: AttrType): valueType,
    ...
}
----

For example, to define a user type with `firstName` String, `lastName` String and `age` Number, the syntax is:

.DataWeave Script
----
%dw 2.0
output application/json

type User = {
    firstName: String,
    lastName: String,
    age: Number
}
----

You can apply some modifiers to each key value pair to determine if a field is always present or if the field can be repeated or not.

For repeated fields use `*`. For example, the following type allows to have multiple `lastName` fields:

.DataWeave Script
----
%dw 2.0
output application/json

{
    firstName: String,
    lastName*: String,
    age: Number
}
----

For conditional fields use `?`. For example, the following type allows the age field to be present or not:

.DataWeave Script
----
%dw 2.0
output application/json

{
    firstName: String,
    lastName*: String,
    age?: Number
}
----

==== Close and Open Objects

Close object means that the type only accepts an object value if there are no additional fields in the object,
just those key values specified by the type.

Open object only put constraints on the fields that are declared in the type, and if they are all verified, then the type accepts the value. The type accepts objects that have other fields apart of the ones mentioned in the declaration. All object types are open unless specified.

The following example works even if `age` is not mentioned in the type declaration because the type of the variable `user` is an open object:

.DataWeave Script
----
%dw 2.0
output application/json

var user: {firstName: String, lastName: String} = {firstName: "John", lastName: "Smith", age: 34}
----

The syntax to specify a close object is `{| |}`. The following example, makes our user type only support the keys `firstName` and `lastName`, so this throws an exception because the `age` field is not accepted.

.DataWeave Script
----
%dw 2.0
output application/json

var user: {|firstName: String, lastName: String|} = {name: "John", lastName: "Smith", age: 34}
----


=== Function Type

DataWeave is a functional language and functions are a first class citizen which means that functions are values
and values have an associated type.

The syntax to define a function type is:

----
(paramType: ParamType,...) -> ReturnType
----

For example, if you want to define in a constraint a function type that has a parameter of type String, a second parameter of type Number and return a Boolean, the correct syntax is:

----
(paramA: String, paramB: Number) -> Boolean
----

For example, you could define a function that receives another function as an argument:

.DataWeave Script
----
%dw 2.0
output application/json

fun applyIDsChange(ids: Array<Number>, changeTo: (Number) -> Number): Array<Number> = ???
----

If we call the function `applyIDsChange` with some function that does not match the `changeTo` constraint `(Number) -> Number`, DataWeave throws a type checking error.
For example, the following call works because `abs` is a function that takes a Number and returns a Number, which matches the `changeTo` parameter.

----
applyIDsChange([1,-6, 3, -8], abs)
----

But this call fails because `sum` is a function that takes an Array and returns a Number, so it does not match our parameter constraint.

----
applyIDsChange([1,-6, 3, -8], sum)
----

== Complex Types

=== Any and Nothing

In some cases you can not enforce a restriction as it accepts all the values. +

* `Any` type accepts all possible values.
* `Nothing` type accepts no value but it can be assigned to all the types. This type is not frequently used explicitly but it is by the type inference algorithm.

=== Union Type

Union type is used to compose types. The syntax to define a union type is:

----
TypeA | TypeB | ...
----

The following example defines a variable with a constraint that accepts a value of type String or Number:

----
var age: String | Number = if (payload.allStrings) "32" else 32
----

A common pattern is to use Null with a union type to specify that a type accepts null as a value. In the following example, the variable `a` accepts that the expression `payload.foo` returns `null`.

----
var a: String| Null = payload.foo
----


=== Intersection Type

The intersection type intersects object types. In this case, the intersection works as the concatenation (`++`) of object types.

_Introduced in DataWeave 2.3.0. Supported by Mule 4.3 and later._

The syntax for intersection type is:
----
TypeA & TypeB & ...
----

In the following example, the intersection concatenates the two object types resulting in the type `{name: String, lastName: String}` This is an open object so it can have more key value pairs. The variable accepts the value assigned to it:

----
var a: {name: String} & {lastName: String} = {name: "John", lastName: "Smith", age: 34}
----

In the case of close objects, it returns the concatenation of the object types but resulting in a close object. +
In the following example, the intersection results in the type `{|name: String, lastName: String|}`. This throws
an exception because a close object does not accept an object value if there are additional fields in the object (field `age`):

----
var a: {|name: String|} & {|lastName: String|} = {name: "John", lastName: "Smith", age: 34}
----

[[literal-types]]
=== Literal Types

A literal type represents exactly one value. For example, the String value `"foo"` can be represented with the type `"foo"`.

_Introduced in DataWeave 2.3.0. Supported by Mule 4.3 and later._

The following literal types have been added to the type system:

* String literal types
* Number literal types
* Boolean literal types

You can use literal types with union types when you want to declare a type as a finite set of allowed values. For example, the following types declarations are aliases of union and literals types:

----
type Weekdays = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday"
type Days = Weekdays | "Saturday" | "Sunday"
----

In the following example, the variable only accepts a value of these specific literal types (`404` and `500`). The type system ensures that the variable is one of those literal values:

.DataWeave Script
----
%dw 2.0
output application/json

var errorStatusCode: 404 | 500 = payload.statusCode
----

With function overloading you are able to define different behaviors based on the input argument value:

.DataWeave Script
----
%dw 2.0
import * from dw::core::Strings
output application/json

fun errorHandling(errorCode: 404 | 405, response): String = "Code for error 4XX handling here!"
fun errorHandling(errorCode: 500 | 501, response): String = "Code for error 5XX handling here!"
---
errorHandling(payload.statusCode, payload)
----

At runtime, the function dispatching algorithm selects the correct function based on the actual type of the value of `payload.statusCode`. It is not necessary to check the value of an argument with an if statement to change the behaviour of the function.
