= Execution Engine
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: mule, threading, scheduler, non-blocking

Mule runtime engine implements a Reactive execution engine, tuned for non-blocking and asynchronous execution. Its task-oriented execution model enables you to take advantage of non-blocking IO at high concurrency levels transparently, meaning you don’t need to account for threading or asynchronicity in your flows. Each operation inside a Mule flow is a task that provides metadata about its execution, and Mule makes tuning decisions based on that metadata.

Mule Event processors indicate to Mule whether they are CPU intensive, CPU light, or IO intensive operations. These workload types help Mule tune for different workloads, so you don’t need to manage thread pools manually to achieve optimum performance. Instead, Mule introspects the available resources (such as memory and CPU cores) in the system to tune thread pools automatically.

[[processing_types]]
== Processing Types

Mule Event processors indicate to Mule what kind of work they do, which can be one of:

* CPU Light
For quick operations (around 10ms), or Non-Blocking IO, for example, a Logger (`logger`) or HTTP Request operation (`http:request`). These tasks should not perform any blocking IO. The applicable strings in the logs are `CPU_LIGHT` and `CPU_LIGHT_ASYNC`.
* Blocking IO
For IO that blocks the calling thread, for example, a Database Select operation (`db:select`) or a SFTP read (`sftp:read`) . Applicable strings in the logs are `BLOCKING` and `IO`.
* CPU Intensive
For CPU-bound computations, usually taking more than 10ms to execute. These tasks should not perform any IO activities. Examples include the Transform Message component (`ee:transform`). The applicable string in the logs is `CPU_INTENSIVE`.

See specific component or module documentation to learn the processing type it supports. If none is specified, the default is CPU Light.
// link to https://docs.mulesoft.com/mule-sdk/1.1/non-blocking-operations#execution-types
For connectors created with the Mule SDK, the SDK determines the most
appropriate processing type based on how the connector is implemented. For
details on that mechanism, refer to the xref:1.1@mule-sdk::index.adoc[Mule SDK documentation].

[[threading]]
== Threading

Based on the processing type of a component, Mule executes that component on a thread pool that is specifically tuned for that kind of work. These thread pools are managed by Mule and shared across all apps in the same Mule instance.
When started, Mule introspects the available resources (such as memory and CPU cores) in the system to tune thread pools automatically for the environment where it is running. The default configuration was established through performance testing, which found optimal values for most scenarios.

The different thread pools allow Mule to manage resources more efficiently, requiring significantly fewer threads (and their inherent memory footprint) to handle a given workload when compared to Mule 3.

Following are described the key aspects of each thread pool.

=== CPU Light

CPU Light is for a relatively small thread pool (2 threads per available core by default).

Apart from executing the CPU Light processors, this pool performs the handoff
of the event between processors in the flow (including the routers) and the
response handling for non-blocking IO.

In an app, when throughput drops or becomes unresponsive, it might be due to some code
misusing the CPU Light thread pool. This can be quickly checked by taking a
thread dump of the runtime and looking for `WAITING` or `BLOCKED` or for
long-running processes in the CPU Light threads.

=== CPU Intensive

CPU Intensive is also a small thread pool (2 threads per available core by default),
but it provides a queue for accepting more tasks.

=== IO

IO is an elastic thread pool that grows as needed.

Tasks running in this pool should spend most of their time `WAITING` or `BLOCKED`
instead of doing CPU work, so they do not compete with the other pools.

Also, when a transaction is active (since many transaction managers require all
steps of a same transaction to be handled by the same thread), the `IO` pool
is used.

=== Custom Pools

Apart from the three core thread pools, Mule or some components might create additional pools for specific purposes, such as:

* NIO Selectors
Enables non-blocking IO. Each connector can create as many as required.
* Recurring tasks pools
Some connectors or components might create specific pools to perform recurring tasks (e.g: expiration monitors, queue consumers, etc.)

[[backpressure]]
== Back-pressure

Under heavy load, Mule might not have resources available to handle a specific event. This issue might occur because all threads are busy and cannot perform the handoff of the newly arrived event or because the current flow’s `maxConcurrency` value has been exceeded already.
In case Mule cannot handle an event, a message is logged about the condition: `Flow 'flowName' is unable to accept new events at this time`. Also, Mule sends a notification to the flow source to perform any required actions.
The actions Mule performs on back-pressure are specific to each connector’s source. For example, an `http:listener` might return a `503` error code, while a message broker listener might provide the option to either wait for resources to be available or drop the message. In some cases, a source might disconnect from a remote system to avoid getting more data than it can process and then reconnect once the server state is normalized.
