= Type System
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

DataWeave 2.0 introduced a new type system on the language. To understand how values for these types are defined see xref:dataweave-types.adoc[Value Constructs for DataWeave Types] documentation.

A type system defines a set of constraints to a set of constructs such as:

* Variables
* Function parameters

These constraints are used in the type checking phase where DataWeave ensures that the values assigned
to variables or the arguments for a function call respects its constraints.

For example:

----
var userName: String = "John"
----

The variable definition for `userName` has the constraint of assigning a value of type String.
If some other type value is assigned, a type checking error raises.

----
fun toUser(id: Number, userName: String): String = "you called the function toUser!"
----

The constraints to call the function `toUser` are that the first argument has to be of type Number, the second one of type String (or to be coercible to those types) and the result of the function has to be of type String.

----
toUser(123, "John")
toUser("123", true)
----

Both calls don't throw an exception. In the case of the second function call, there is an autocoercion of the String `"123"` to the Number value `123`, and the Boolean `true` to the String value `"true"` to being able to call the function. +
An example of a call that throws a type checking error is `toUser("a 12", "John")` because the String `"a 12"` isn't coercible to a Number. +

DataWeave also uses a global type inference algorithm to validate your code even if no type is specified as
constraints.

Note that the use of constraints are optional but this can be useful in big scripts or multiple scripts where the type system could help you avoid bugs in your DataWeave logic by running the type checking algorithm.

The types supported by the DataWeave type system are divided into three categories:

* Simple Types
* Composite Types
* Complex Types

== Simple Types

Simple types represent values such as String, Boolean, etc. These values are atomic, they are not composed by other values. The list of simple types are:

* String
* Boolean
* Number
* Regex
* Null
* Temporal: Date, DateTime, LocalDateTime, LocalTime, Time, Period
//Key, KeyValuePairType, NameType, NameValuePairType, NamespaceType, RangeType , ReferenceType, TypeParameter, TypeType, UriType

=== Null

Null is a type of only one value, which means that `null` can not be assigned to the type String or any other type except for the type Null.

For example, the repeat function in the String Module has the signature `repeat(String, Number): String`, which means that only accepts as a first parameter a value of type String, and as a second parameter a value of type Number. The function returns a value of type String.

----
repeat("a", 3)
----

This returns `&quot;aaa&quot;`, but:

----
repeat(null, 3)
----

Throws an error because the value `null` can not be assigned to the parameter that expects a value of type String.

----
repeat(Null, 3)
----

In this case we are assigning to the first parameter a value that is the type Null (the type of this value
is `Type&lt;Null&gt;`), and returns `&quot;NullNullNull&quot;` because there is an autocoercion that coerce the value to be of type String (`&quot;Null&quot;`).

Some other functions may have an overloaded signature for the function (the function has multiples definitions for different parameters types) that let it be called with `null`.

For example, the map function has the signature `map(Array&lt;T&gt;, (T, Number)-&gt;R): Array&lt;R&gt;` (receives an Array of elements of type `T` (this is a type parameter), a function, and returns an Array of elements of type `R`) but it is also defined as `map(Null, (Nothing, Nothing)-&gt;Any): Null`. +

So if you call the function map with a null (`null map (item, index) -&gt; item`) this does not throw an exception because map is defined for null as its first parameter. +
The type system chooses the correct function definition with the function dispatching algorithm.
This returns null because of the definition of map for null.

== Composite Types

Composite types contains other values inside it. These composite types are Array, Object and Function.

=== Array Type

An Array is of type `Array&lt;T&gt;` where `T` is a type parameter that defines the type of the elements inside the Array. +
For example, the syntax to define an Array of Number as `Array&lt;Number&gt;` is:

----
var idsList: Array<Number> = [1, 22, 333, 4444]
----

The variable `idsList` only passes the type checking phase when the array assigned to it only contains Numbers.

=== Object Type

In order to define an object type there are two ways, either `Object` or `{}`, they both define an _open object_ and does not specify any constraint to their key value pairs. Open and close objects are later defined in this section.

The syntax to define an object type with a set of constraints for its key value pairs, is very similar to defining an object value:

----
{
    keyName @(attrName: AttrType): valueType,
    ...
}
----

For example, to define a user type with `firstName` String, `lastName` String and `age` Number, the syntax is:

----
type User = {
    firstName: String,
    lastName: String,
    age: Number
}
----

You can apply some modifiers to each key value pair to determine if a field is always present or if the field can be repeated or not.

For repeated fields use `*`. For example, the following type allows to have multiple `lastName` fields:

----
{
    firstName: String,
    lastName*: String,
    age: Number
}
----

For conditional fields use `?`. For example, the following type allows the age field to be present or not:

----
{
    firstName: String,
    lastName*: String,
    age?: Number
}
----

==== Close and Open Objects

Close object means that the type only accepts an object value if there are no additional fields in the object,
just those key values specified by the type.

Open object only puts constraints on the fields that are declared in the type, and if they are all verified, then the type accepts the value. The type accept objects that have other fields apart of the ones mentioned in the declaration. All object types are open unless specified.

The following example works even if `age` is not mentioned in the type declaration because the type of the variable `user` is an open object:

----
var user: {firstName: String, lastName: String} = {firstName: "John", lastName: "Smith", age: 34}
----

The syntax to specify a close object is `{| |}`. The following example, makes our user type only supports the keys `firstName` and `lastName`, so this throws an exception because of the `age` field is not accepted.

----
var user: {|firstName: String, lastName: String|} = {name: "John", lastName: "Smith", age: 34}
----


=== Function Type

DataWeave is a functional language and functions are a first class citizen which means that functions are values
and values have an associated type.

The syntax to define a function type is:

----
(paramType: ParamType,...) -> ReturnType
----

For example, if you want to define a function that has a parameter of type String, a second parameter of type Number and return a Boolean, the correct syntax is:

----
(paramA: String, paramB: Number) -> Boolean
----

For example, you could define a function that receives another function as an argument:

----
fun findUserIndex(arr: Array<User>, condition: (userInArray: User, targetUser: User) -> Boolean): User = ???
----

If we call the function `findUserIndex` with some function that does not match the `condition` constraint `(User, User) -> Boolean`, DataWeave throws a type checking error.


== Complex Types

=== Any and Nothing

In some cases you can not enforce a restriction as it accepts all the values. +

* `Any` type accepts all possible values.
* `Nothing` type accepts no value but it can be assigned to all the types. This type is not frequently used explicitly but it is by the type inference algorithm.

=== Union Type

Union type is used to compose types. The syntax to define a union type is:

----
TypeA | TypeB | ...
----

The following example defines a type that accepts any String and any Number:

----
var age: String | Number = ???
----

A common patter is to use Null with a union type to specify that a type accepts null as a value. In the following example, the variable `a` accepts that the expression `payload.foo` returns `null`.

----
var a: String| Null = payload.foo
----


=== Intersection Type

The intersection type intersects object types. In this case, the intersection works as the concatenation (`++`) of object types.

_Introduced in DataWeave 2.3.0. Supported by Mule 4.3 and later._

The syntax for intersection type is:
----
TypeA & TypeB & ...
----

In the following example, the intersection concatenates the two object types resulting in the type `{name: String, lastName: String}` This is an open object so it can have more key value pairs. The variable accepts the value assigned to it:

----
var a: {name: String} & {lastName: String} = {name: "John", lastName: "Smith", age: 34}
----

In the case of close objects, it returns the concatenation of the object types but resulting in a close object. +
In the following example, the intersection results in the type `{|name: String, lastName: String|}`. This throws
an exception because a close object does not accept an object value if there are additional fields in the object (field `age`):

----
var a: {|name: String|} & {|lastName: String|} = {name: "John", lastName: "Smith", age: 34}
----


=== Literal Types

The literal type represents exactly one value. For example, the String value `"foo"` can be represented with the type `"foo"`.

_Introduced in DataWeave 2.3.0. Supported by Mule 4.3 and later._

The following literal types have been added to the type system:

* String literal types
* Number literal types
* Boolean literal types

You can use literal types with union types when you want to declare a type as a finite set of allowed values. For example, the following types declarations are aliases of union and literals types:

----
type Weekdays = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday"
type Days = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
----

In the following example, the variable only accepts the specific literal types (`404` and `500`). The type system ensures that the variable is one of those literal values:

----
var errorStatusCode: 404 | 500 = payload.statusCode
----

With function overloading you are able to define different behaviors based on the input argument value:

----
fun errorHandling(errorCode: 404 | 405, response): String = "Code for error 4XX handling here!"
fun errorHandling(errorCode: 500 | 501, response): String = "Code for error 5XX handling here!"
---
errorHandling(payload.statusCode, payload)
----

The type system chooses the correct function definition depending on the value of `payload.statusCode`. It is not necessary to check the value of an argument with an if statement to change the behaviour of the function.
